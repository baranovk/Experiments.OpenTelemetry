Решение **Experiments.OpenTelemetry** было реализовано как эксперимент и прототип функционала мониторинга на основе семейства библиотек OpenTelemetry.

Для этого был разработан "каркас" некоторой системы, которая состоит из:

1. Хост, который с определенной периодичностью запускает активности

2. Активности, которые запускаются хостом (или другими активностями) и в свою очередь запускают другие активности или операции

3. Операции, которые выполняют некоторую "работу" и/или запускают другие операции.

При этом предполагается, что хост, активности и операции на определенных этапах своей работы отправляют метрики, которые позволяют мониторить процесс. 

Метрики аккумулируются в Prometheus, откуда их можно запросить и отобразить на нескольких дашбордах в Grafana. А также настроить на основе этих метрик набор алертов.

Кроме метрик компоненты отправляют трейсы в Jaeger. С их помощью можно делать трассировку (distributed tracing) шагов процесса выполнения задания: Хост -> Активность -> Операция (отслеживать длительность этапов обработки; на каком этапе произошла ошибка и по какой причине; визуализировать процесс обработки и т.д.).

Отправка метрик и трейсов осуществляется с помощью семейства библиотек OpenTelemetry - https://opentelemetry.io/docs/languages/dotnet/. Промежуточный коллектор не используется, метрики и трейсы отправляются в хранилище непосредственно в процессе работы активностей/операций.

### Структура решения

Все проекты решения собраны в папке **src** в корне проекта.

* **Experiments.OpenTelemetry.Host**. Проект, реализующий хост, который запускает (ставит в очередь) entrypoint-активность - _Experiments.OpenTelemetry.Host.EntryPointActivity_. EntryPointActivity добавляет в очередь список work items на обработку (просто список целых чисел - эмуляция входных данных для активности/операций), а затем в случайном порядке запускает либо активность _Experiments.OpenTelemetry.Library1.Library1Activity_ или _Experiments.OpenTelemetry.Library2.Library2Activity.

* **Experiments.OpenTelemetry.Library1**. Проект, который содержит одну активность _Library1Activity_ и несколько операций: _Library1OperationA_, _Library1OperationB_ и т.д. _Library1Activity_ просто запускает первую операцию - _Library1OperationA_ и передает ей данные на обработку. _Library1OperationA_ эмулирует обработку данных (создает случайную задержку - длительность задержки настраивается), затем запускает _Library1OperationB_. Та тоже эмулирует работу, запускает _Library1OperationС_ и так по цепочке вплоть до _Library1OperationD_

* **Experiments.OpenTelemetry.Library2**. Проект, аналогичный _Experiments.OpenTelemetry.Library1_. Реализует еще один набор активностей и операций.

* **Experiments.OpenTelemetry.Common**. Проект содержит функциональность, общую для всех активностей/операций. Каждая активность/операция наследуется от класса _Experiments.OpenTelemetry.Common.ActivityBase_, в котором реализован метод 
_ExecuteAsync_, вызываемый средой выполнения при запуске активности/операции. Этот метод состоит из трех частей: 

    - **Пролог**. Стартует очередного span для трассировки, отправляет обновление для метрики "кол-во выполняющихся     активностей" (увеличивает счетчик)
    - **Функционал унаследованного класса активности/операции**. Здесь выполняется основная "бизнес-логика" обработки.
    - **Эпилог**. Отправляет обновление для метрики "кол-во выполняющихся активностей" (уменьшает счетчик), отправляет метрику  времени выполнения активности/операции (по этой метрике можно построить гистограмму времени выполнения и отслеживать     активности/операции, которые выполняются долго). Если при обработке произошла ошибка - отправляет обновление для счетчика   ошибок с указанием типа ошибки.

    **Итого:** базовый класс для всех активностей/операций обновляет метрики, базовые для всех активностей/операций:

    - кол-во выполняющихся в данный момент активностей/операций
    - время работы активности/операции
    - счетчик ошибок
    - можно добавить дополнительные общие метрики, которые будут собираться для ВСЕХ активностей

* **Experiments.OpenTelemetry.Telemetry**. Проект содержит функционал настройки типов метрик, которые отправляются из активностей/операций, а также реализацию интерфейса _ITelemetryCollector_, в котором определены методы для отправки метрик. "Под капотом" TelemetryCollector использует библиотеку _OpenTelemetry.Exporter.OpenTelemetryProtocol_, с помощью которой отправляет метрики по протоколу OTLP в Prometheus.

* **Experiments.OpenTelemetry.Configurator**. Консольное приложение, с помощью которого можно менять конфигурацию хоста во время выполнения. Хост при запуске запускает в бэкграунде сервер приема и обработки команд/запросов через сокет. _Experiments.OpenTelemetry.Configurator_ может эти команды отправлять и отображать полученные от сервера ответы. 
    
    Команды, которые реализованы на данный момент:
    - **PrintConfigurationParametersCommand** - печать текущих параметров конфигурации хоста
    - **ChangeMaxConcurrentActivitiesCountScenario** - изменение кол-ва активностей/операций, которые могут запускаться одновременно

### Инфраструктура

В папке _.infrastructure_ в корне проекта собраны Docker Compose/Docker файлы и конфигурация для сервисов, внешних для хоста: Prometheus, Grafana, Jaeger, Alertmanager. Также есть общий _docker-compose.yml_, который позволяет запустить в докере все сервисы разом.

Для запуска инфраструктуры на рабочей машине с Windows понадобиться установить Docker Desktop.

- Prometheus (сбор и хранение метрик). http://localhost:9090
- Grafana (дашборды). http://localhost:3000. При запуске подключаются три дащборда: Главный дашборд, Work Items (статус обработки элементов данных), Ошибки
- Jaeger (трейсы). http://localhost:16686
- Alertmanager. http://localhost:9093
- Structurizr. http://localhost:8090. Архитектурные схемы проекта в формате С4

### Запуск проекта

Для запуска проекта нужно:

1. Запустить инфраструктуру с помощью файла _/.infrastructure/docker/docker-compose.yml_

2. Запустить проект хоста _Experiments.OpenTelemetry.Host_ либо с помощью Visual Studio, либо просто запустить exe-файл проекта.

3. Дополнительно можно запустить exe конфигуратора _Experiments.OpenTelemetry.Configurator_ для контроля/настройки параметров работы хоста.